# 电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。  
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
![picture](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)  
示例：
```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
说明:  
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
## 回溯算法
回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。
```c++
class Solution {
public:
    vector<string>result;
    map<string, string>phone = {
        {"2","abc"},{"3","def"},{"4","ghi"},{"5","jkl"},
        {"6","mno"},{"7","pqrs"},{"8","tuv"},{"9","wxyz"}
    };
    void backtrack(string combination, string next_digits) {
        if (next_digits == "") {
            result.push_back(combination);
        }
        else {
            string digits = next_digits.substr(0,1);
            string letters = phone[digits];
            for (int i=0; i<letters.length(); i++) {
                string letter = letters.substr(i, 1);
                backtrack(combination + letter, next_digits.substr(1));
            }
        }
        
    }
    
    vector<string> letterCombinations(string digits) {
        if (digits != "") {
            backtrack("", digits);
        }
        return result;
    }
};
```
复杂度分析

- 时间复杂度: O(3^N * 4^M), 其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8), M 是输入数字中对应 4 个字母的数目（比方说 7，9）,N+M 是输入数字的总数。  

- 空间复杂度: O(3^N * 4^M), 这是因为需要保存(3^N * 4^M)个结果。

# KMP
```c++
#include <iostream>
#include <string>
using namespace std;
 
void getnext(string p, int next[])
{
    int i = 0, j = -1;
    next[0] = -1;
    while(i < p.length()-1)
    {
	if(j == -1 || p[i] == p[j])		//向前匹配；		
        {
	    j++;			
	    i++;
	    next[i] = j;			    //为next数组赋值；
	}
	else
	    j = next[j];		        //往前回溯；
    }
}

int kmpmatch(char *s, char *t)
{
    int i = 0, j = 0;
    int n = strlen(s);
    int m = strlen(t);
    int *next = new int[m+1];
    getnext(t, next);
    while(i < n && j < m)
    {
	if(j == -1 || s[i] == t[j])        //满足条件则向下一个字符匹配；
	{
	    j++;
	    i++;
	}
	else
	    j = next[j];    //子字符串向前回溯；主字符串下标不变；
    }
    if(j == m)
	return i - m;        //返回子字符串在主字符串中第一次出现的位置；
    else
	return -1;            //没有找到则返回-1；
}
 
int main()
{
    char *str = "ababcabcacb";
    char *ptr = "abcac";
    cout << str << endl << ptr << endl;
    int result = kmpmatch(str, ptr);
    if(result == -1)
        cout <<"没有匹配结果" << endl;
    else
        cout << "在第 " << result+1 << " 个字符位置首次出现" << endl;
    return 0;
}
```
