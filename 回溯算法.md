# 电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。  
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
![picture](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)  
示例：
```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
说明:  
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
## 回溯法
回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。
```c++
class Solution {
public:
    vector<string>result;
    map<string, string>phone = {
        {"2","abc"},{"3","def"},{"4","ghi"},{"5","jkl"},
        {"6","mno"},{"7","pqrs"},{"8","tuv"},{"9","wxyz"}
    };
    void backtrack(string combination, string next_digits) {
        if (next_digits == "") {
            result.push_back(combination);
        }
        else {
            string digits = next_digits.substr(0,1);
            string letters = phone[digits];
            for (int i=0; i<letters.length(); i++) {
                string letter = letters.substr(i, 1);
                backtrack(combination + letter, next_digits.substr(1));
            }
        }
        
    }
    
    vector<string> letterCombinations(string digits) {
        if (digits != "") {
            backtrack("", digits);
        }
        return result;
    }
};
```
复杂度分析

- 时间复杂度: O(3^N * 4^M), 其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8), M 是输入数字中对应 4 个字母的数目（比方说 7，9）,N+M 是输入数字的总数。  

- 空间复杂度: O(3^N * 4^M), 这是因为需要保存(3^N * 4^M)个结果。
# 括号生成
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。  
例如，给出 n = 3，生成结果为：
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```
## 暴力法
思路：用递归将每一种可能都列出来再判断是否合法
```c++
vector<string> result;
bool isvaild(string s) {
    int balance = 0;
    for(auto c : s) {
        if (c == '(') {
            balance++;
        }
        else
            balance--;
        if (balance < 0) {
            return false;
        }
    }
    return balance == 0;
}

void generateAll(string s, int n) {
    if (s.length() == 2 * n) {
        if (isvaild(s)) {
            result.push_back(s);
        }
    }
    else {
        string left = s + '(';
        generateAll(left, n);
        string right = s + ')';
        generateAll(right, n);
    }
}

vector<string> generateParenthesis(int n) {
    
    if (n <= 0) {
        return result;
    }
    
    string s;
    generateAll(s, n);
    
    return result;
}
```
复杂度分析：  
- 时间复杂度：O(2^2n * n),对于 2^2n 个序列中的每一个，我们用于建立和验证该序列的复杂度为O(n).
- 空间复杂度：O(2^2n * n),简单地,每个序列都视作是有效的.
## 回溯法
思路：不跟递归一样一一列举，就只判断有用的情况
```c++
void backtrace(string s, int open, int close, int n) {
    if (s.length() == 2 * n) {
        result.push_back(s);
    }
    if (open < n) {
        backtrace(s + '(', open + 1, close, n);
    }
    if (close < open) {
        backtrace(s + ')', open, close + 1, n);
    }
}

vector<string> generateParenthesis(int n) {
    
    if (n <= 0) {
        return result;
    }

    backtrace("", 0, 0, n);
    return result;
}
```
