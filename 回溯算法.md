# KMP
```c++
#include <iostream>
#include <string>
using namespace std;
 
void getnext(string p, int next[])
{
    int i = 0, j = -1;
    next[0] = -1;
    while(i < p.length()-1)
    {
	if(j == -1 || p[i] == p[j])		//向前匹配；		
        {
	    j++;			
	    i++;
	    next[i] = j;			    //为next数组赋值；
	}
	else
	    j = next[j];		        //往前回溯；
    }
}

int kmpmatch(char *s, char *t)
{
    int i = 0, j = 0;
    int n = strlen(s);
    int m = strlen(t);
    int *next = new int[m+1];
    getnext(t, next);
    while(i < n && j < m)
    {
	if(j == -1 || s[i] == t[j])        //满足条件则向下一个字符匹配；
	{
	    j++;
	    i++;
	}
	else
	    j = next[j];    //子字符串向前回溯；主字符串下标不变；
    }
    if(j == m)
	return i - m;        //返回子字符串在主字符串中第一次出现的位置；
    else
	return -1;            //没有找到则返回-1；
}
 
int main()
{
    char *str = "ababcabcacb";
    char *ptr = "abcac";
    cout << str << endl << ptr << endl;
    int result = kmpmatch(str, ptr);
    if(result == -1)
        cout <<"没有匹配结果" << endl;
    else
        cout << "在第 " << result+1 << " 个字符位置首次出现" << endl;
    return 0;
}
```

# 电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。  
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
![picture](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)
示例：
```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
说明:  
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
