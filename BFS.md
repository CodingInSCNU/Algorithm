# 机器人的运动范围
地上有一个 ```m``` 行 ```n``` 列的方格，从坐标 ```[0,0]``` 到坐标 ```[m-1,n-1]``` 。一个机器人从坐标 ```[0, 0]``` 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当 ```k``` 为 ```18``` 时，机器人能够进入方格 ```[35, 37]``` ，因为 ```3 + 5 + 3 + 7 = 18```。但它不能进入方格 ```[35, 38]```，因为 ```3 + 5 + 3 + 8 = 19```。请问该机器人能够到达多少个格子？

示例 1：
```
输入：m = 2, n = 3, k = 1
输出：3
```
示例 1：
```
输入：m = 3, n = 1, k = 0
输出：1
```
## 方法一：BFS
我们将行坐标和列坐标数位之和大于 ```k``` 的格子看作障碍物，那么这道题就是一道很传统的搜索题目，我们可以使用广度优先搜索或者深度优先搜索来解决它，本文选择使用广度优先搜索的方法来解。  

计算数位之和就不多做叙述了。  

这道题还有一个隐藏的优化：我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。为什么呢？  
>因为假设 ```m, n``` 不变，随着 ```k``` 值的增加，```(0, 0)``` 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到.  
![picture](https://pic.leetcode-cn.com/eb360a76b26e583f23a5c8743c6f398f84be3d292d17179327f8c57ddab784b0-幻灯片7.JPG)  

这里有一个隐藏的问题：  
读者可能以为是 ```m * n``` 矩阵中**所有**行列位数之和满足条件就计数器加一，但结果并不对，不是吗？为什么呢？  
>因为小机器人是从 ```(0, 0)``` 开始往下或者往右走的，那如果它所有往下和往右的路都是不能走的呢？也就是说它的路被断了，详细看上图。  

所以我们可以使用 ```BFS``` 来遍历，使用队列才存储能走的路，如果队列空了，也就是说无路可走了，此时返回就好。   

```c++
int get(int x) {
    int res = 0;
    while (x) {
        res += x % 10;
        x /= 10;
    }
    return res;
}

int movingCount(int m, int n, int k) {
    if (!k) return 1;
    queue<pair<int,int> > Q;
    // 向右和向下的方向数组
    int dx[2] = {0, 1};
    int dy[2] = {1, 0};
    vector<vector<int>> vis(m, vector<int>(n, 0));
    Q.push(make_pair(0, 0));
    vis[0][0] = 1;
    int ans = 1;
    while (!Q.empty()) {
        auto [x, y] = Q.front();
        Q.pop();
        // 往下或者往右
        for (int i = 0; i < 2; ++i) {
            int tx = dx[i] + x;
            int ty = dy[i] + y;
            if (tx < 0 || tx >= m || ty < 0 || ty >= n || vis[tx][ty] || get(tx) + get(ty) > k) continue;
            Q.push(make_pair(tx, ty));
            vis[tx][ty] = 1;
            ans++;
        }
    }
    return ans;
}
```
复杂度分析
- 时间复杂度：```O(mn)```，其中 ```m``` 为方格的行数，```n``` 为方格的列数。考虑所有格子都能进入，那么搜索的时候一个格子最多会被访问的次数为常数，所以时间复杂度为 ```O(2mn) = O(mn)```.  
- 空间复杂度：```O(mn)```，其中 ```m``` 为方格的行数，```n``` 为方格的列数。搜索的时候需要一个大小为 ```O(mn)``` 的标记结构用来标记每个格子是否被走过。  

## 方法二：递推
考虑到方法一提到搜索的方向只需要朝下或朝右，我们可以得出一种递推的求解方法。  

算法：
定义 ```vis[i][j]``` 为 ```(i, j)``` 坐标是否可达，如果可达返回 ```1```，否则返回 ```0```。

首先 ```(i, j)``` 本身需要可以进入，因此需要先判断 ```i``` 和 ```j``` 的数位之和是否大于 ```k``` ，如果大于的话直接设置 ```vis[i][j]``` 为不可达即可。

否则，前面提到搜索方向只需朝下或朝右，因此 ```(i, j)``` 的格子只会从 ```(i - 1, j)``` 或者 ```(i, j - 1)``` 两个格子走过来（不考虑边界条件），那么 ```vis[i][j]``` 是否可达的状态则可由如下公式计算得到：
>```vis[i][j] = vis[i-1][j] or vis[i][j-1]```  

即只要有一个格子可达，那么 ```(i, j)``` 这个格子就是可达的，因此我们只要遍历所有格子，递推计算出它们是否可达然后用变量 ```ans``` 记录可达的格子数量即可。

初始条件 ```vis[i][j] = 1``` ，递推计算的过程中注意边界的处理。  

```c++
int get(int x) {
    int res = 0;
    while (x) {
        res += x % 10;
        x /= 10;
    }
    return res;
}

int movingCount(int m, int n, int k) {
    if (!k) return 1;
    vector<vector<int> > vis(m, vector<int>(n, 0));
    int ans = 1;
    vis[0][0] = 1;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if ((i == 0 && j == 0) || get(i) + get(j) > k) continue;
            // 边界判断
            if (i - 1 >= 0) vis[i][j] |= vis[i - 1][j];
            if (j - 1 >= 0) vis[i][j] |= vis[i][j - 1];
            ans += vis[i][j];
        }
    }
    return ans;
}
```












































