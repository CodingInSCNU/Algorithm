# 最长回文串
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:
```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```
Algorithm：
对于每个字符 ```ch```，假设它出现了 ```v``` 次，我们可以使用该字符 ```v / 2 * 2``` 次，在回文串的左侧和右侧分别放置 ```v / 2``` 个字符 ```ch```，
其中 ```/``` 为整数除法。例如若 ```"a"``` 出现了 5 次，那么我们可以使用 ```"a"``` 的次数为 4，回文串的左右两侧分别放置 2 个 ```"a"```。  

如果有任何一个字符 ```ch``` 的出现次数 ```v``` 为奇数（即 ```v % 2 == 1```），那么可以将这个字符作为回文中心，注意只能最多有一个字符作为回文中心。
在代码中，我们用 ```ans``` 存储回文串的长度，由于在遍历字符时，```ans``` 每次会增加 ```v / 2 * 2```，因此 ```ans``` 一直为偶数。但在发现了第一个出现
次数为奇数的字符后，我们将 ```ans``` 增加 1，这样 ```ans``` 变为奇数，在后面发现其它出现奇数次的字符时，我们就不改变 ```ans``` 的值了。
```c++
int longestPalindrome(string s) {
    unordered_map<char, int> count;
    int ans = 0;
    for (char c : s)
        ++count[c];
    for (auto p : count) {
        int v = p.second;
        ans += v / 2 * 2;
        if (v % 2 == 1 and ans % 2 == 0)
            ++ans;
    }
    return ans;
}
```
---
# [跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:
```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
说明:

假设你总是可以到达数组的最后一个位置。

```c++
int jump(vector<int>& nums) {
    int maxPos = 0, n = nums.size(), end = 0, step = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (maxPos >= i) {
            maxPos = max(maxPos, i + nums[i]);
            if (i == end) {
                end = maxPos;
                ++step;
            }
        }
    }
    return step;
}
```




















