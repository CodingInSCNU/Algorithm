# 有效括号的嵌套深度
有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。

嵌套深度 ```depth``` 定义：即有效括号字符串嵌套的层数，```depth(A)``` 表示有效括号字符串 ```A``` 的嵌套深度。详情参见题末「嵌套深度」部分。

给你一个「有效括号字符串」 ```seq```，请你将其分成两个不相交的有效括号字符串，```A``` 和 ```B```，并使这两个字符串的深度最小。

不相交：每个 ```seq[i]``` 只能分给 ```A``` 和 ```B``` 二者中的一个，不能既属于 ```A``` 也属于 ```B``` 。  
- ```A``` 或 ```B``` 中的元素在原字符串中可以不连续。  
- ```A.length + B.length = seq.length```  
- ```max(depth(A), depth(B))``` 的可能取值最小。  
- 划分方案用一个长度为 ```seq.length``` 的答案数组 ```answer``` 表示，编码规则如下：

- ```answer[i] = 0```，```seq[i]``` 分给 ```A``` 。  
- ```answer[i] = 1```，```seq[i]``` 分给 ```B``` 。
如果存在多个满足要求的答案，只需返回其中任意 一个 即可。  

示例 1：
```
输入：seq = "(()())"
输出：[0,1,1,1,1,0]
```
示例 2：
```
输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
```
提示：
- ```1 <= text.size <= 10000```  

题解：
这题的题目描述可能有点费解，首先要知道有效括号的意思，一句话概括就是每个左括号都可以找到在它右边的与其对应的右括号。如果不知道什么是有效括号的话可以先看一下这一道题：[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

题面最后 ```answer``` 的意思就是，为 0 的部分对应 ```seq``` 的括号是 ```A``` 字符串，为1的部分对应 ```seq``` 的括号是 ```B``` 字符串。
示例1：
```
输入：seq = "(()())"
输出：[0,1,1,1,1,0]
```
```answer``` 的意思是下面这个样子。红色部分是 ```A``` 串，蓝色部分是 ```B``` 串。
![p](https://pic.leetcode-cn.com/04d5010f0145eefdc6595b29e1088fc0f2c8efcbef9ced16227d668cf0fd6efc-image.png)

示例2：
```
输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
```
对应的 ```answer``` 的图示：  
![p](https://pic.leetcode-cn.com/fd04742c31901af648fb9cac4771836a5d9567a7ef6ddafd8a519cc02e5ea361-image.png)   
题面也说了 ```answer``` 的答案是不唯一的，下面这样也是可以的：  
![p](https://pic.leetcode-cn.com/1675fd60b68a835009fbdc509d86ecb2045de7b48a4510a3864e93571547ec2e-image.png)  

下面说做法：

我假设你已经做过上面的题目了，知道需要用栈辅助判断。题面中的 ```depth``` 其实就是栈的最大深度。“你需要从中选出任意一组有效括号字符串 ```A``` 和 ```B```，使 ```max(depth(A), depth(B))``` 的可能取值最小”。这句话其实相当于让 ```A``` 字符串和 ```B``` 字符串的 ```depth``` 尽可能的接近。为什么呢？因为 ```seq``` 对应的栈上，每个左括号都对应一个深度，而这个左括号，要么是 ```A``` 的，要么是 ```B``` 的。所以，栈上的左括号只要按奇偶分配给 ```A``` 和 ```B``` 就可以啦！
至于如何判断奇偶：
只要在遍历过程中，我们保证栈内一半的括号属于序列 ```A```，一半的括号属于序列 ```B```，那么就能保证拆分后最大的嵌套深度最小，是当前最大嵌套深度的一半。要实现这样的对半分配，我们只需要把奇数层的 ```(``` 分配给 ```A```，偶数层的 ```(``` 分配给 ```B``` 即可。对于上面的例子，我们将嵌套深度为 1 和 3 的所有括号 ```(())``` 分配给 ```A```，嵌套深度为 2 的所有括号 ```()()()``` 分配给 ```B```。  

```c++
vector<int> maxDepthAfterSplit(string seq) {
    vector<int> answer(seq.length());
    int idx = 0;
    for(char c: seq) {
        answer[idx++] = c == '(' ? idx & 1 : ((idx + 1) & 1);
    }
    return answer;
}
```
复杂度分析：
- 时间复杂度：O(n)  
- 空间复杂度：O(n)  



















